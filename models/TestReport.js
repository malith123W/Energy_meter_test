const mongoose = require('mongoose');

const testReportSchema = new mongoose.Schema({
  // Header Information
  reportNumber: {
    type: String,
    required: false, // Auto-generated by pre-save hook
    unique: true,
    trim: true
  },
  dateOfTested: {
    type: Date,
    required: [true, 'Date of tested is required'],
    default: Date.now
  },
  branch: {
    type: String,
    required: [true, 'Branch is required'],
    trim: true
  },
  depot: {
    type: String,
    required: false,
    trim: true
  },
  csc: {
    type: String,
    required: [true, 'CSC (Customer Service Center) is required'],
    trim: true
  },
  location: {
    type: String,
    required: [true, 'Location is required'],
    trim: true
  },
  substationNumber: {
    type: String,
    required: [true, 'Substation number is required'],
    trim: true
  },
  accountNumber: {
    type: String,
    required: [true, 'Account number is required'],
    trim: true
  },
  contractDemand: {
    type: String,
    required: [true, 'Contract demand is required'],
    trim: true
  },
  reason: {
    type: String,
    required: [true, 'Reason is required'],
    enum: ['routine', 'complaint', 'replacement', 'verification', 'other'],
    default: 'routine'
  },
  requestedBy: {
    type: String,
    trim: true
  },
  requestId: {
    type: String,
    required: [true, 'Request ID is required'],
    trim: true
  },

  // Current Transformer Section
  currentTransformer: {
    make: {
      type: String,
      required: [true, 'CT Make is required'],
      trim: true
    },
    ratio: {
      type: String,
      required: [true, 'CT Ratio is required'],
      trim: true
    }
  },

  // Static Meter Section
  staticMeter: {
    make: {
      type: String,
      required: [true, 'Meter Make is required'],
      trim: true
    },
    serialNumber: {
      type: String,
      required: [true, 'Meter Serial Number is required'],
      trim: true
    },
    meterConstant: {
      type: String,
      required: [true, 'Meter Constant is required'],
      trim: true
    },
    class: {
      type: String,
      required: [true, 'Meter Class is required'],
      trim: true
    },
    meterCurrent: {
      type: String,
      required: [true, 'Meter Current is required'],
      trim: true
    },
    meterVoltage: {
      type: String,
      required: [true, 'Meter Voltage is required'],
      trim: true
    },
    testerMake: {
      type: String,
      required: [true, 'Tester Make is required'],
      trim: true
    },
    testerSerialNumber: {
      type: String,
      required: [true, 'Tester Serial Number is required'],
      trim: true
    }
  },

  // Check Section
  checkSection: {
    physicalCondition: {
      type: String,
      required: [true, 'Physical condition is required'],
      enum: ['Good', 'Fair', 'Poor'],
      default: 'Good'
    },
    ctRatio: {
      type: String,
      required: [true, 'CT Ratio is required'],
      trim: true
    },
    meterRatio: {
      type: String,
      required: [true, 'Meter Ratio is required'],
      trim: true
    },
    multiplyingFactor: {
      type: Number,
      required: [true, 'Multiplying Factor is required'],
      min: 0
    },
    connectionOfMeterElements: {
      type: String,
      required: [true, 'Connection of meter elements is required'],
      enum: ['3ph4w', '3ph3w', '1ph2w'],
      default: '3ph4w'
    },
    phaseSequence: {
      type: String,
      required: [true, 'Phase sequence is required'],
      enum: ['Correct', 'Incorrect'],
      default: 'Correct'
    },
    ctEarthing: {
      type: String,
      required: [true, 'CT Earthing is required'],
      enum: ['Yes', 'No'],
      default: 'Yes'
    },
    errorAsFound: {
      type: Number,
      required: [true, 'Error as found is required']
    },
    errorAsLeft: {
      type: Number,
      required: [true, 'Error as left is required']
    }
  },

  // Measurings Section
  measurings: {
    energyKWh: {
      totalImport: {
        type: Number,
        required: [true, 'Total Import Energy is required'],
        min: 0
      },
      rateAImport: {
        type: Number,
        required: [true, 'Rate A Import Energy is required'],
        min: 0
      },
      rateBImport: {
        type: Number,
        required: [true, 'Rate B Import Energy is required'],
        min: 0
      },
      rateCImport: {
        type: Number,
        required: [true, 'Rate C Import Energy is required'],
        min: 0
      },
      totalExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateAExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateBExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateCExport: {
        type: Number,
        default: 0,
        min: 0
      }
    },
    demandKVA: {
      totalImport: {
        type: Number,
        required: [true, 'Total Import Demand is required'],
        min: 0
      },
      rateAImport: {
        type: Number,
        required: [true, 'Rate A Import Demand is required'],
        min: 0
      },
      rateBImport: {
        type: Number,
        required: [true, 'Rate B Import Demand is required'],
        min: 0
      },
      rateCImport: {
        type: Number,
        required: [true, 'Rate C Import Demand is required'],
        min: 0
      },
      totalExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateAExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateBExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateCExport: {
        type: Number,
        default: 0,
        min: 0
      }
    },
    reactiveEnergyKVArh: {
      totalImport: {
        type: Number,
        required: [true, 'Total Import Reactive Energy is required'],
        min: 0
      },
      rateAImport: {
        type: Number,
        required: [true, 'Rate A Import Reactive Energy is required'],
        min: 0
      },
      rateBImport: {
        type: Number,
        required: [true, 'Rate B Import Reactive Energy is required'],
        min: 0
      },
      rateCImport: {
        type: Number,
        required: [true, 'Rate C Import Reactive Energy is required'],
        min: 0
      },
      totalExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateAExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateBExport: {
        type: Number,
        default: 0,
        min: 0
      },
      rateCExport: {
        type: Number,
        default: 0,
        min: 0
      }
    },
    averagePowerFactor: {
      type: Number,
      required: [true, 'Average Power Factor is required'],
      min: 0,
      max: 1
    }
  },

  // Phases Section
  phases: {
    voltage: {
      r: {
        type: Number,
        required: [true, 'R Phase Voltage is required'],
        min: 0
      },
      y: {
        type: Number,
        required: [true, 'Y Phase Voltage is required'],
        min: 0
      },
      b: {
        type: Number,
        required: [true, 'B Phase Voltage is required'],
        min: 0
      }
    },
    current: {
      rPrimary: {
        type: Number,
        required: [true, 'R Phase Primary Current is required'],
        min: 0
      },
      rSecondary: {
        type: Number,
        required: [true, 'R Phase Secondary Current is required'],
        min: 0
      },
      yPrimary: {
        type: Number,
        required: [true, 'Y Phase Primary Current is required'],
        min: 0
      },
      ySecondary: {
        type: Number,
        required: [true, 'Y Phase Secondary Current is required'],
        min: 0
      },
      bPrimary: {
        type: Number,
        required: [true, 'B Phase Primary Current is required'],
        min: 0
      },
      bSecondary: {
        type: Number,
        required: [true, 'B Phase Secondary Current is required'],
        min: 0
      }
    }
  },

  // Comments and Signatures
  comments: {
    type: String,
    trim: true,
    maxlength: [1000, 'Comments cannot exceed 1000 characters']
  },
  technicalOfficerSignature: {
    type: String,
    trim: true
  },
  chiefEngineerSignature: {
    type: String,
    trim: true
  },

  // System fields
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  reportFilePath: {
    type: String,
    trim: true
  },
  status: {
    type: String,
    enum: ['draft', 'pending_technical', 'pending_chief', 'approved', 'rejected_technical', 'rejected_chief'],
    default: 'pending_technical'
  },
  
  // Technical Officer Approval
  technicalOfficerApprovedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  technicalOfficerApprovedAt: {
    type: Date
  },
  technicalOfficerRejectedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  technicalOfficerRejectedAt: {
    type: Date
  },
  technicalOfficerRejectionReason: {
    type: String,
    trim: true
  },
  
  // Chief Engineer Approval
  chiefEngineerApprovedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  chiefEngineerApprovedAt: {
    type: Date
  },
  chiefEngineerRejectedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  chiefEngineerRejectedAt: {
    type: Date
  },
  chiefEngineerRejectionReason: {
    type: String,
    trim: true
  },

  // Legacy fields for backward compatibility
  approvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  approvedAt: {
    type: Date
  },
  rejectedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  rejectedAt: {
    type: Date
  },
  rejectionReason: {
    type: String,
    trim: true
  }
}, {
  timestamps: true
});

// Create compound index for efficient searching
testReportSchema.index({ branch: 1, dateOfTested: -1 });
testReportSchema.index({ substationNumber: 1 });
testReportSchema.index({ accountNumber: 1 });
testReportSchema.index({ depot: 1 });

// Generate report number before saving
testReportSchema.pre('save', async function(next) {
  // Only generate report number for new documents and if not already set
  if (!this.isNew || this.reportNumber) return next();
  
  try {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    
    // Find the last report for this month
    const lastReport = await this.constructor.findOne({
      reportNumber: new RegExp(`^FT-${year}${month}-`)
    }).sort({ reportNumber: -1 });
    
    let sequence = 1;
    if (lastReport && lastReport.reportNumber) {
      const parts = lastReport.reportNumber.split('-');
      if (parts.length === 3) {
        const lastSequence = parseInt(parts[2]);
        if (!isNaN(lastSequence)) {
          sequence = lastSequence + 1;
        }
      }
    }
    
    this.reportNumber = `FT-${year}${month}-${String(sequence).padStart(4, '0')}`;
    console.log('Generated report number:', this.reportNumber);
    next();
  } catch (error) {
    console.error('Error generating report number:', error);
    next(error);
  }
});

module.exports = mongoose.model('TestReport', testReportSchema);

